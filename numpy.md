创建NumPy数组

创建NumPy数组有几种形式。

第一种，假如已经有了数组表达式或值，这通常来源于前期数据导入代码或者其他库，在这里只需要将其转换成NumPy数组即可。如下列代码，a为列表，通过np.array()将其转换为NumPy的ndarray类型。

```
a = [[1,2,3],[4,5,6]
a2 = np.array(a)
print (type(a2))
NumPy.ndarray
```

注意：

array函数支持Python创建的列表和元素。
array()内的值一定是元素或列表，而不能是其他值。
array()转换后的对象类型会根据默认为实际可用值，也可手动指定。
当然，很多场景下被转换的变量可能不是上述“现成” 的矩阵，这时候需要我们“手动”进行转换。如下列代码，原始被转换的变量是一个1行15列的数组，这时候我们需要根据实际需求将其转换为3行5列的数组，通过reshape函数即可实现。

```
>>> import NumPy as np
>>> a3 = np.arange(15).reshape(3, 5)
>>> print a3
[[ 0, 1, 2, 3, 4],
 [ 5, 6, 7, 8, 9],
 [10, 11, 12, 13, 14]]
```

第二种，某些时候数组里面的值可能是未知的，但矩阵的大小其实是已经确定的，比如我们了解到接下来的运算中需要一个3行4列的矩阵，那么就可以利用NumPy创建矩阵。当然，矩阵的值可能为空，也可以是某些特定值，这取决于创建的方法。

方法一：使用zeros创建全为0的矩阵。如下代码创建了一个3行4列且值全为0的二维矩阵。
```
>>> a4 = np.zeros((3,4))
>>> print a4
[[0., 0., 0., 0.],
 [0., 0., 0., 0.],
 [0., 0., 0., 0.]]
 ```

方法二：使用ones创建全为1的矩阵。如下代码创建了一个三维，每个维都是3行4列的矩阵。
```
>>> a5 = np.ones((3,4))
>>> print a5
[[[ 1, 1, 1, 1],
  [ 1, 1, 1, 1],
  [ 1, 1, 1, 1]],
 [[ 1, 1, 1, 1],
  [ 1, 1, 1, 1],
  [ 1, 1, 1, 1]]]
``` 

方法三：使用empty创建一个内容随机并且依赖与内存状态的数组。如下代码创建了一个2行3列的矩阵，但值为随机产生。这种创建方法一般很少使用。
```
>>> a6 = np.ones((2,3))
>>> print a6
[[ 3.73603959e-262, 6.02658058e-154, 6.55490914e-260],
 [ 5.30498948e-313, 3.14673309e-307, 1.00000000e+000]]
 ```

默认情况下，创建的矩阵对象类型是float64，也可以通过dtype创建时指定对象类型。

方法四：使用arange或者linspace创建一个新的数值序列数组。
```
#使用arange创建从10到30，步长为5的数值序列，其中开始数值10以及步长5都是可选设置
>>> a7 = np.arange( 10, 30, 5 )
>>> print a7
[10, 15, 20, 25]
#使用linspace创建从0到2，一共9个数值的序列
>>> a8 = np.linspace( 0, 2, 9 )
>>> print a8
[ 0. , 0.25, 0.5 , 0.75, 1. , 1.25, 1.5 , 1.75, 2. ]
``` 

arange函数和linspace都可以创建固定起止数值的数组，但二者的区别在于arange通过控制步长确定数组个数，而linspace直接设置个数（而自动设置步长）。

以上时常用创建数组的方法，更多细节函数请见：array, zeros, zeros_like, ones, ones_like, empty, empty_like, arange, linspace, rand, randn, fromfunction, fromfile

简单的NumPy数组运算

数组间简单运算
```
>>> arr1 = np.array([[1., 2., 3.], [4., 5., 6.]])
>>> arr2 = np.array([[2., 3., 4.], [5., 6., 7.]])
#数组加法
>>> print arr1 + arr2
[[3, 5, 7],
 [9, 11, 13]]
#数组减法
>>> print arr1 – arr2
[[-1, -1, -1],
 [-1, -1, -1]]
#数组乘法
>>> print arr1 * arr2
[[2, 6, 12],
 [20, 30, 42]]
#数组除法
>>> print arr1 / arr2
[[0.5, 0.6667, 0.75],
 [0.8, 0.8333, 0.8571]]
 ```

数组与数值运算

数组与数值运算的基本方法与数组间运算语法相同，在此只举一个例子，其余参加数组间语法。
```
>>> arr1 = np.array([[1., 2., 3.], [4., 5., 6.]])
#数组与数值加法
>>> print (arr1 + 2)
[[3 , 4, 5],
 [6 , 7, 8]]
#数组与数值减法
>>> print (arr1 – 2)
[[-1, 0, 1],
 [2, 3, 4]]
#数组与数值乘法
>>> print (arr1 * 2)
[[2, 4, 6],
 [8, 10, 12]]
#数组与数值除法
>>> print (arr1 / 2)
[[0.5, 1, 1.5],
 [2, 2.5, 3]
 ```

注意：数组与数值间的运算不仅可以有整数，小数也可以有。那么问题来了，如果是arr1 * 0.5结果会是什么呢？会有什么规律？这个交给大家来发掘吧。（提示：将结果对照上述的四则运算）
数组函数运算

通用函数( 又称ufunc)是一个在ndarrays的数据上进行基于元素的操作的函数。NumPy提供常见的数学函数如sin、cos和exp，也提供简单的统计函数如mean, std, vary等。实际上，之前我们已经在使用一些通用函数了，例如生成有序序列的arange、生成全为1的zeros函数等。 这部分重点介绍的是NumnPy的常用来做计算的函数。
```
>>> arr = np.arange(4)
>>> print arr
[0, 1, 2, 3]
#求arr的绝对值
>>> print np.abs(arr)
[0, 1, 2, 3]
#求arr的平方根
>>> print np.sqrt(arr)
[0, 1, 1.414, 1.732]
#求arr的平方
>>> print np.square(arr)
[0, 1, 4, 9]
#求arr的指数
>>> print np.exp(arr)
[1, 2.728, 7.389, 20.086]
#求arr以e为底的对数
>>> print np.log(arr)
[-inf, 0, 0.693, 1.099]
#求arr每个元素的正负号
>>> print np.sign(arr)
[0, 1, 1, 1]
#求arr每个元素的cos值
>>> print np.cos(arr)
[1, 0.540, -0.416, -0.990]
 ```

以下提供了相对完整的常用数组运算函数的列表。更多细节，请访问NumPy Example List了解更多信息。

 

函数	描述
abs, fabs	计算基于元素的整形，浮点或复数的绝对值。fabs对于没有复数数据的快速版本
sqrt	计算每个元素的平方根。等价于 arr ** 0.5
square	计算每个元素的平方。等价于 arr ** 2
exp	计算每个元素的指数。
log, log10, log2, log1p	自然对数（基于e），基于10的对数，基于2的对数和 log(1 + x)
sign	计算每个元素的符号：1(positive)，0(zero)， -1(negative)
ceil	计算每个元素的天花板，即大于或等于每个元素的最小值
floor	计算每个元素的地板，即小于或等于每个元素的最大值
rint	圆整每个元素到最近的整数，保留dtype
modf	分别返回分数和整数部分的数组
isnan	返回布尔数组标识哪些元素是 NaN （不是一个数）
isfinite, isinf	分别返回布尔数组标识哪些元素是有限的（non-inf, non-NaN）或无限的
cos, cosh, sin sinh, tan, tanh	regular 和 hyperbolic 三角函数
arccos, arccosh, arcsin, arcsinh, arctan, arctanh	反三角函数
logical_not	计算基于元素的非x的真值。等价于 -arr
 

数组统计运算

数据统计是Python做数据分析的重要步骤，NumPy提供了常用的求和、均值、方差、标准差、最大最小值、累积等函数。以下以sum求和函数为例解释使用方法，其余函数用法类似。
```
>>> arr = np.arange(6).reshape(2,3)
>>> print arr
[[0, 1, 2],
 [3, 4, 5]]
#求arr的全部（行和列）的总和
>>> print np.sum(arr)
15
#大多数情况下，我们会指定求某列或某行的和
#求基于列的和
>>> print np.sum(arr, axis = 1)
[3, 12]
#求基于行的和
>>> print np.sum(arr, axis = 0)
[3, 5, 7]
 ```

以下列表是常用的NumPy的统计函数。更多细节，请访问NumPy Example List了解更多信息。

sum	对数组的所有或一个轴向上的元素求和。零长度的数组的和为灵。
mean	算术平均值。灵长度的数组的均值为NaN。
std, var	标准差和方差，有可选的调整自由度（默认值为n）。
min, max	最大值和最小值
argmin, argmax	索引最小和最大元素。
cumsum	从0元素开始的累计和。
cumprod	从1元素开始的累计乘。
注意：本部分是使用Python做机器学习等场景下经常使用的函数，每个函数的用法都需要牢记。
NumPy数组预处理

数据预处理是在进行数据挖掘、探索、学习之前的必要步骤，NumPy提供了较多的数据预处理功能。例如转置、索引、切片、数组间函数处理、逻辑条件表达式、排序、集合等。

NumPy数组转置

数组转置是将数据进行矩阵“对换”的一种方式，NunPy提供了transpose函数和.T属性两种是实现形式。
```
#一维数组转置
>>> arr = np.arange(6)
>>> print arr
[0, 1, 2, 3, 4, 5]
>>> print np.transpose(arr)
[0, 1, 2, 3, 4, 5]#一维还是一维…
#二维数组转置
>>> arr = np.arange(6).reshape((2,3))
>>> print arr
[[0, 1, 2],
 [3, 4, 5]]
>>> print np.transpose(arr)
[[0,3],
 [1,4],
 [3,5]]
#三维数组的转置
>>> arr = np.arange(24).reshape((2,3,4))
>>> print arr
[[[ 0, 1, 2, 3],
   [ 4, 5, 6, 7],
   [ 8, 9, 10, 11]],
  [[ 12, 13, 14, 15],
   [ 16, 17, 18, 19],
   [ 20, 21, 22, 23]]]
>>> print np.transpose(arr)
[[[0, 12],
  [4, 16],
  [8, 20]],
 [[1, 13],
  [5, 17],
  [9, 21]],
 [[2, 14],
  [6, 18],
  [10, 22]],
 [[3, 15],
  [7, 19],
  [11, 23]]]
#当数组>=三维之后，我们可能希望按照特定规则来转置，transpose 可以接受用于指定转置的坐标轴号码的元组
>>> print np.transpose(arr, (1,0,2))
[[[ 0, 1, 2, 3],
  [ 12, 13, 14, 15]],
 [[ 4, 5, 6, 7],
  [ 16, 17, 18, 19]],
 [[ 8, 9, 10, 11],
  [ 20, 21, 22, 23]]]
 ```

对于是否指定转化规则，具体来看三维的变化：原始数据的“三维”是(2,3,4)，不指定转换规则后的“三维”是(4,3,2)，而指定规则后的三维则是按照我们指定的规则，将其一维和二维进行调换。
```
#原始三维数据规则
>>> print (arr.shape)
(2, 3, 4)
#不指定转换规则
>>> print (np.transpose(arr).shape)
(4, 3, 2)
#指定转换规则
>>> print (np.transpose(arr,(1, 0, 2)).shape)
(3, 2, 4)
 ```

ndarray的T属性，用法则比较简单，只需要在数组后跟.T即可。.T属性实际是转置里面的特殊情况，即不指定转置规则的默认规则。
```
#一维数组转置
>>> arr = np.arange(6)
>>> print arr
[0, 1, 2, 3, 4, 5]
>>> print arr.T
[0, 1, 2, 3, 4, 5]#一维还是一维…
#二维数组转置
>>> arr = np.arange(6).reshape((2,3))
>>> print arr
[[0, 1, 2],
 [3, 4, 5]]
>>> print arr.T
[[0,3],
 [1,4],
 [3,5]]
#三维数组的转置
>>> arr = np.arange(24).reshape((2,3,4))
>>> print arr
[[[ 0, 1, 2, 3],
   [ 4, 5, 6, 7],
   [ 8, 9, 10, 11]],
  [[ 12, 13, 14, 15],
   [ 16, 17, 18, 19],
   [ 20, 21, 22, 23]]]
>>> print arr.T
[[[0, 12],
  [4, 16],
  [8, 20]],
 [[1, 13],
  [5, 17],
  [9, 21]],
 [[2, 14],
  [6, 18],
  [10, 22]],
 [[3, 15],
  [7, 19],
  [11, 23]]]
``` 

当某些情况下，你可能只需要转换其中的两个轴，除了可以使用transpose指定轴以外（当然需要每个轴都指定顺便，只是调整其中的部分而已），还可以使用swapreaxes。
```
>>> arr = np.arange(24).reshape((2,3,4))
>>> print arr
[[[ 0, 1, 2, 3],
   [ 4, 5, 6, 7],
   [ 8, 9, 10, 11]],
  [[ 12, 13, 14, 15],
   [ 16, 17, 18, 19],
   [ 20, 21, 22, 23]]]
>>> print arr.swapaxes(1, 0)
[[[ 0, 1, 2, 3],
  [ 12, 13, 14, 15]],
 [[ 4, 5, 6, 7],
  [ 16, 17, 18, 19]],
 [[ 8, 9, 10, 11],
  [ 20, 21, 22, 23]]]
```

```
seq = np.sin(xs)
res = np.cos(xs)
```


```
import numpy as np
import time
start_time = time.time()

n1 = np.random.rand(3,3,2)
n2 = np.zeros((512, 512, 2))

x_index = 0

print(n1)

for x in n1:
    y_index = 0
    for y in x:
        n2[x_index, y_index] = y
        y_index = y_index + 1
    x_index = x_index + 1


#
# for x in range():
#     for x in x_row:
```

